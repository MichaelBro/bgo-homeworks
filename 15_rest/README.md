# Домашнее задание к занятию «4.4. REST»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **разных репозиториях**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Ознакомьтесь с [дополнительным материалом про объединение таблиц](joins.md)
1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Добавьте в него в качестве зависимостей pgx v4
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Library

ReMux, который вы разработали, достаточно неплох (для начала, конечно же). Почему бы его не использовать так же, как мы используем, например, pgx? `go get` и т.д.

Например, вы делаете несколько проектов:
* свой личный веб-сервис (pet project)
* пару проектов для своих друзей

Не копировать же каталог с ReMux'ом в каждый из них? Ведь если вы захотите исправить ошибку (в ReMux'е), тогда придётся править во всех трёх. **Важно**: мы не призываем вас использовать везде этот ReMux, наша задача - научить вас работать с модулями.

**Важно**: дочитайте до конца, прежде чем выполнять какие-либо команды.

Соответственно, здесь всё предельно просто (но есть несколько тонких моментов): вы можете `go get` и URL вашего репо (без https), например, `go get github.com/netology-code/bgo-remux`.

С точки зрения всей экосистемы Go здесь есть одна опасность: представьте, что чей-то проект стал очень популярным и от него зависит большое количество других проектов. Что произойдёт, если автор по каким-то причинам удалит свой проект? Правильно, все, кто не сохранил копию, останутся с нерабочими проектами.

Поэтому в экосистеме Go введён в строй специальный сервис https://proxy.golang.org/, который сохраняет всё, что вы скачиваете через `go get`.

Это, в свою очередь, ведёт к следующим вещам:
1. Теперь уже вы не можете удалить свой репозиторий (в рамках обучения, если у вас что-то не получилось) и начать всё с нуля
1. Новые версии на proxy.golang.org ваших библиотек будут появляться с определённой задержкой, что в случае разработки (когда вы делаете ДЗ) достаточно критично, потому что кто захочет ждать 5-10 минут, пока сможет скачать обновлённую версию?

За настройки, связанные с этим отвечают несколько переменных окружения Go. Для работы с переменными окружения для самого Go есть команда `go env`:
1. `go env` - печать всех переменных окружения Go
1. `go env GOPROXY` - печать конкретной переменной
1. `go env -w GOPROXY=value` - установка значения конкретной переменной

Давайте посмотрим на них внимательно:
```shell
go env GOPROXY
# https://proxy.golang.org,direct
```

Эта строка значит, что `go get` попытается скачать любой модуль сначала с proxy.golang.org и только если он там не найден, попробует скачать напрямую по URL (direct). Можно оставить только `direct` (`go env GOPROXY=direct`), но это не очень хороший вариант, давайте рассмотрим другие.

`GOPRIVATE` специальная переменная окружения, позволяющая вам настраивать список URL'в, для которых proxy.golang.org использоваться не будет (приватные модули). Например, если мы хотим, чтобы все модули с `github.com/netology-code` и `github.com/coursar` были приватными:
```shell
go env -w GOPRIVATE=github.com/netology-code,github.com/coursar
```

После этого спокойно можете подключать ваш модуль к новому проекту.

Что нужно сделать: создайте новый проект, к которому подключите ReMux (из задания №1). В этом проекте создайте простенький сервис, который работает следующим образом:
1. GET /api/pages - возвращает список страниц (id, название, картинка и дата создания)
1. GET /api/pages/:id - возвращает страницу по id (id, название, картинка, основной текст и дата создания)
1. POST /api/pages - создаёт новую страницу (передаёте название, картинку и основной текст, возвращаете созданный объект и код 201)
1. PUT /api/pages/:id - обновляет существующую страницу (передаёте название, картинку и основной текст, возвращаете обновлённый объект)
1. DELETE /api/pages/:id - удаляет существующую страницу (возвращаете код 204)
1. Любые запросы на все остальные URL'ы должны возвращать 404

Страницы можете хранить в памяти. Страница из себя представляет объект с 5 полями:
1. id
1. Название
1. Картинка
1. Основной текст
1. Дата создания

Ваш сервис отдаёт и принимает JSON, в случае картинки будем считать, что за загрузку отвечает другой сервис - вы же принимаете в качестве картинки просто URL.

Id и дата создания должны рассчитываться автоматически.

<details>
<summary>Дополнительная информация</summary>

В качестве примера используйте https://journal.tinkoff.ru/ (конечно же там гораздо больше полей). И, конечно же, данные должны храниться в СУБД.

Обратите внимание: иногда запрос на добавление и на обновление объединяют в один POST /api/pages, отличая их друг от друга тем, что при создании id передаётся равным 0. Использовать данный подход или нет - это ваше решение.
</details>

Итого у вас должно быть: репозиторий с проектом, использующим ваш же (не наш, а ваш - который вы выложили в отдельный репо с Recoverer'ом) ReMux.

## Задача №2 - Recoverer*

**Важно**: это не обязательная задача, её (не)выполнение не влияет на получение зачёта по ДЗ.

Когда мы только начинали изучать стандартный http-сервер, мы увидели, что он умеет перехватывать панику, но при этом не отдаёт какого-то "вразумительного" ответа клиента.

Что мы хотим сделать: мы хотим, чтобы вы разработали middleware под названием Recoverer, которое перехватывает возможную панику в хэндлерах и записывает в ответ статус-код 500 (Internal Server Error).

На лекции мы рассмотрели создание логгера в качестве middleware, соответственно, Recoverer вам нужно создать по его образу и подобию.

Не забудьте написать авто-тесты, аналогичные тем, что мы писали на лекции (т.е. вам понадобится написать ещё и хендлер, который выкидывает панику).

Итого у вас должно быть:
1. Репозиторий с ReMux'ом и middleware Recoverer
1. Автотесты на Recoverer (конечно же, подключенные к GitHub Actions)

Помимо ссылки на репо, пришлите текстом или разместите в файле README.md ответ на следующий вопрос: что произойдёт, если хендлер уже записал что-то в ответ (заголовок, заголовок и часть данных) и только потом выкинул панику? Каков будет результат попытки Recoverer'а выставить статус-код?

Это один из интересных вопросов, которые достаточно часто спрашивают на собеседовании, чтобы определить ваш уровень понимания работы с `ResponseWriter`'ом.

