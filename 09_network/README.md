# Домашнее задание к занятию «3.2. Работа с сетью, HTTP 1.1, HTTP 2»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **одном репозитории**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Export

На лекции мы с вами смотрели на то, как можно экспортировать данные в формат CSV. Но помимо CSV, вы ещё знаете про JSON. Соответственно, ваша задача заключается в том, чтобы на базе кода с лекции сделать то же самое (экспорт) для JSON.

По-хорошему, вам нужно сходить в RFC и поискать MIME типы для JSON. Если вдруг так случилось, что вы их не нашли, то смотрите в подсказку.

<details>
<summary>MIME типы для JSON</summary>

Content-Type для JSON - `application/json`
</details>

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub (автотесты делать не нужно*).

Примечание*: мы отдельно будем разговаривать, как нужно будет делать автотесты на TCP и HTTP сервисы.

## Задача №2 – Медленные клиенты*

**Важно**: это не обязательная задача, её (не)выполнение не влияет на получение зачёта по ДЗ.

Тот сервер, который мы написали на лекции, обладает одним фатальным недостатком - он не решает никак проблему медленных клиентов.

О чём идёт речь? Представим, что у нас есть клиент, который отправляет запрос со скоростью 1 байт в секунду. Поскольку наш сервер "однопоточный" (в единицу времени мы можем обрабатывать только одного клиента) то новых клиентов мы обрабатывать не сможем.

Давайте убедимся в этом, а потом вы исправите этот момент.

Писать мы будем по-прежнему на уровне TCP (обратите внимание, сервер должен быть запущен и работать):

```go
func main() {
	if err := execute(); err != nil {
		os.Exit(1)
	}
}

func execute() (err error) {
	conn, err := net.Dial("tcp", "localhost:9999")
	if err != nil {
		log.Println(err)
		return err
	}
	defer func(c io.Closer) {
		if cerr := c.Close(); cerr != nil {
			log.Println(cerr)
			if err == nil {
				err = cerr
			}
		}
	}(conn)

	request := []byte("GET / HTTP/1.1\r\n")
	for i := range request {
		time.Sleep(time.Second)
		part := request[i:i+1]
		log.Printf("write: %s", part)
		_, err = conn.Write(part)
		if err != nil {
			log.Println(err)
			return err
		}
	}
	log.Println("request finished")

	return nil
}
```

Теперь запустите ваш сервер и запустите клиент. У вас есть 16 секунд на то, чтобы в браузере вбить `http://localhost:9999` и увидеть, что браузер повиснет в режиме ожидания.

Это очень плохо. Поскольку если таких клиентов будет много, то у нас получится медленная очередь.

Самый первый вариант, который у нас есть (помимо "отстрела" медленных клиентов) - это использовать горутины для обработки подключающихся клиентов.

Вам достаточно проанализировать код веб-сервера с лекции и вынести обработку каждого подключающегося клиента в горутину. 

<details>
<summary>Подсказка</summary>

На самом деле, вам достаточно всего в одном месте поставить `go`.
</details>

Оформите данное улучшение в виде Pull Request'а к задаче №1.

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub (автотесты делать не нужно).

## Доп.материал: Deadlines

**Важно**: это не ДЗ, сдавать его не нужно. Вы лишь должны прочитать этот раздел и убедиться, что поняли его.

У `net.Conn` есть методы для установки дедлайнов, как на чтение данных, так и на запись. При этом если операции ввода-вывода не завершились к отведённому времени, то мы получим ошибку.

Здесь ключевой момент, который нам нужно пояснить: дедлайн - это некая метка времени. Дедлайн не нужно путать с таймаутом. Таймаут - это текущее время (`time.Now()`) + некоторое смещение (типа `time.Duration`).

Важный вывод, который из этого следует: если мы хотим работать с дедлайнами - мы обязаны их выставлять каждый раз заново:

```go
for {
    conn, err := listener.Accept() // для клиентов
    if err != nil {
        log.Println(err)
        continue
    }
    // conn.SetDeadline одновременно устанавливает дедлайны и на чтение, и на запись, но лучше выставлять отдельно
    conn.SetReadDeadline(time.Now().Add(time.Second * 30))
    conn.SetWriteDeadline(time.Now().Add(time.Minute * 5))
    handle(conn)
}
```

Конечно же, не обязательно выставлять дедлайн прямо здесь, можно это сделать и в `handle`, если мы хотим реализовать более гибкую логику.

Например, в зависимости от того, какой файл клиент запрашивает, может потребоваться гораздо больше 30 секунд на отдачу файла. Здесь важно отметить, что вы можете выставлять дедлайны перед каждым `Read`/`Write`.

Ключевое же: помнить, что их нужно выставлять, и, кроме того, запомнить, чем дедлайны отличаются от таймаутов.

И тут есть небольшой вопрос: когда мы смотрели на HTTP, мы же читали не определённое количество байт, мы использовали буфер, в котором искали `\n`. Это приводит к тому, что если `\n` мы так и не встретим, то будем читать "до конца". С учётом того, что мы читаем в память, то мы легко можем получить переполнение по памяти (кто-нибудь пришлёт нам запрос на пару гигабайт).

Поэтому в промышленных http-серверах, помимо таймаутов на чтение и запись, устанавливаются определённые ограничения на сам запрос, а именно на Request Line + заголовки.

Например, для Apache:
* [Request Line](https://httpd.apache.org/docs/2.4/mod/core.html#limitrequestline)
* [Headers](https://httpd.apache.org/docs/2.4/mod/core.html#limitrequestfieldsize)

Для Nginx: [Request Line & Headers](http://nginx.org/en/docs/http/ngx_http_core_module.html#large_client_header_buffers)
