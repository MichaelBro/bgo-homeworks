# Домашнее задание к занятию «1.3. Структуры, указатели, массивы, slices, maps»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **одном репозитории**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Предисловие

Сегодня мы отработаем типичную ситуацию из жизни программиста: код, который вы напишите, будет занимать несколько десятков строк, но перед тем, как вы его напишите, вам придётся прочитать гораздо больше.

Кроме того, мы специально вынесли описание работы с `map` и операции слайсинга из лекции, чтобы вы потихоньку привыкали к самостоятельной работе с информацией (ведь наша задача – не рассказать вам "всё", а научить, в том числе работать с информацией).

В любом случае, если что-то будет непонятно, не стесняйтесь, пишите в Slack.

## Задача №1 - MCC

### Легенда

Транзакции с кодами, суммами и всем остальным – это хорошо. Но пользователи любят человекопонятные слова, а не коды.

Например, если вы покажете пользователю код MCC 5411 – ему это, скорее всего, ничего не скажет.

Ему будет понятнее, если вы напишите "Супермаркеты" вместо 5411.

Вы можете задать вполне логичный вопрос: "почему бы тогда сразу не писать Супермаркеты?". Всё дело в том, что представление вывода может осуществляться на разных языках (как минимум, английский и русский), поэтому хранится именно код (который никак не привязан к языку), а не перевод.

И отдельно хранится сопоставление кода переводу. 

А теперь подумаем, мы можем это сделать в виде:
1. Массива
1. Слайса
1. Map'а

В случае массивов и слайсов нам будет не совсем удобно, поскольку придётся перебирать все элементы в цикле и смотреть на их коды (а ещё нужно будет создать структуру, в которой сопоставлять MCC конкретному переводу).

Если задуматься, то `map` - как раз это и делает*, сопоставляет некоторому ключу аргументы.

Примечание*: нужно отметить, что в реальных системах переводы достаточно редко "зашивают" прямо в код, чаще всего их хранят в виде отдельных файлов. Но эти файлы так или иначе должны быть прочитаны приложением и внутри вполне себе могут храниться (и достаточно часто хранятся) в виде `map`. Именно поэтому мы и рассматриваем этот вариант.

Как работать с `map`? Почти так же, как со слайсами, но есть свои нюансы.

Давайте по порядку.

### Объявление

Объявлять можно 3-мя способами

#### Способ 1:

```go
var mcc map[string]string // первый string - тип ключа, второй - тип значений
```

#### Способ 2:

```go
mcc := map[string]string{
    "5411": "Супермаркеты",
    "5533": "Автоуслуги",
    "5912": "Аптеки",
}
```

#### Способ 3:

```go
mcc := make(map[string]string)
```

Либо с указанием первоначальной ёмкости:

```go
mcc := make(map[string]string, 3) // рекомендуется только если вы знаете приблизительное количество данных
```

### `len` & `cap`

**Важно**: с `map` (не важно, каким способом вы его объявили) работает только функция `len`, она показывает, сколько есть элементов:

```go
size := len(mcc)
```

**Важно**: нет публичного API для получения текущей ёмкости `map`.

### Запись значений

Запись значений осуществляется достаточно просто – вы указываете ключ и значение к нему (при этом `map` автоматически расширяется при необходимости):

```go
mcc["4111"] = "Транспорт"
```

При этом, если по такому ключу уже существовало какое-то значение, оно будет заменено на новое (т.е. в `map` ключи уникальны и не может быть двух одинаковых ключей, а вот значений – вполне себе, например, MCC-коды 5411 и 5499 могут одинаково переводиться как "Супермаркеты"). 

### Чтение значений

С чтением значений всё гораздо интереснее, есть целых два варианта:

```go
value := mcc["4111"]
// и
value, ok := mcc["4111"]
```

В чём разница? Разница в обработке ситуации с отсутствующим ключом. В отличие от `slice` (который при неверном индексе приводит к аварийному завершению программы*), в `map` вам будет возвращено нулевое значение для типа хранящихся значений `map[string]`**string** (в нашем случае – пустой строке).

И вот тут возникает проблема: либо такого ключа не существовало, либо ключ существовал, но значение действительно пустая строка.

Чтобы разграничить эти варианты, есть вторая форма записи (с `ok`), где в `ok` кладётся `true`, если ключ существует, и `false` – если нет.

Примечание*: на самом деле к панике, но мы пока это называем "аварийное завершение"

### Перебор значений

Для перебора значений используется цикл `for` (других в Go нет) + `range`:
```go
for key, value := range mcc {
    // в key - ключ
    // в value - значения
}
```

### Удаление по ключу

Для удаления по ключу существует специальная builtin-функция `delete` (работает только с `map`):
```go
delete(mcc, "4111")
```

При этом:
1. Если такой ключ существовал, он и значение, к нему привязанное будут удалены
1. Если ключа не было, то ничего не произойдёт

### Особенности

`map` внутри устроен ещё более хитро, чем `slice`. Для интереса, вы можете посмотреть это видео: https://www.youtube.com/watch?v=Tl7mi9QmLns (оно может показаться тяжёлым, но полезно для ознакомления).

Нас будут интересовать только одна особенность: `map` – это структура, которая внутри хранит указатель на массив с данными. Поэтому в функции достаточно передавать сам `map` (по значению, как слайсы) – изменения данных всё равно будут происходить.

### Задача

Вам дана следующая заготовка (пакет `card` файл `mcc.go`):

```go
package card

func TranslateMCC(code string) string { 
    // представим, что mcc читается из файла (научимся позже)
    mcc := map[string]string{
        // TODO: ваш код (необходимые вам MCC-коды)
    }

    // TODO: ваш код
}
```

Допишите в этом файле код таким образом, чтобы мы могли из `main` использовать его вот так:

```go
func main() {
    // TODO: объявление карты и транзакций
    // master = &card.Card{...}
    category := card.TranslateMCC(master.Transactions[0].MCC) 
}
```

Функция `TranslateMCC` должна:
1. Возвращать значение из `map`, если код существует
1. Возвращать строку "Категория не указана", если кода в `map` не найдено

В качестве результата пришлите ссылку на ваш GitHub репозиторий.

## Дополнительное чтение

1. [Go Slices: usage and internals](https://blog.golang.org/slices-intro) и [Arrays, slices (and strings): The mechanics of 'append'](https://blog.golang.org/slices)
1. [Slice Tricks](https://github.com/golang/go/wiki/SliceTricks) – сборник различных трюков по работе со слайсами

